/**
 * 0/1背包 => 模型如下：
 *     给定 N 个物品，其中第 i 个物品的体积为 V[i], 价值为 W[i]。有一容积为 M 的包，要求选择一些物品放入包中，
 * 使得物品总体积不超过 M 的前提下，物品的总价值和最大。
 *     依次考虑每个物品是否放入包，用 "已经处理的物品数" 作为 DP 的 "阶段"，以 "背包中已经放入的物品总体积" 作为附加维度。
 *     F[i,j] 表示从前 i 个物品中选出了总体积为 j 的物品放入背包，物品的最大价值和。
 *     (1) F[i,j] = F[i-1, j]                           不选第 i 个物品
 *     (2) F[i,j] = F[i-1,j-V[i]] + W[i]  if j >= V[i]  选第 i 个物品
 *         F[i,j] = max{F[i-1,j], F[i-1,j-V[i]] + W[i]}
 * 
 *     初值: F[0,0] = 0, 其余均为负无穷。
 *     目标：当 0 <= j <= M，max{F[N][j]}
*/

memset(f, 0xcf, sizeof(f));  // -INF
f[0][0] = 0;
for (int i = 1; i <= n; i++) {
    for (int j = 0; j <= m; j++) {
        f[i][j] = f[i - 1][j];
    }
    for (int j = v[i]; j <= m; j++) {
        f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
    }
}


// 通过 DP 的状态转移方程，我们发现，每一阶段 i 的状态只与上一阶段 i-1 的状态有关。
// 在这种情况下，可以使用称为 "滚动数组" 的优化方法，降低空间开销。

int f[2][MAX_M + 1];
memset(f, 0xcf, sizeof(f)); // -INF
f[0][0] = 0;
for (int i = 1; i <= n; i++) {
    for (int j = 0; j <= m; j++) {
        f[i & 1][j] = f[(i-1) & 1][j];
    }
    for (int j = v[i]; j <= m; j++) {
        f[i & 1][j] = max(f[i & 1][j], f[(i-1) & 1][j - v[i]] + w[i]);
    }
}
int ans = 0;
for (int j = 0; j <= m; j++) {
    ans = max(ans, f[n & 1][j]);
}


// 进一步省略掉 F 数组的第一维，只用一维数组，即当外层循环到第 i 个物品时，
// F[j] 表示背包中放入总体积为 j 的物品的最大价值和。

int f[MAX_M+1];
memset(f, 0xcf, sizeof(f));  // -INF
f[0] = 0;
for (int i = 1; i <= n; i++) {
    for (int j = m; j >= v[i]; j--) {
        f[j] = max(f[j], f[j - v[i]] + w[i]);
    }
}
int ans = 0;
for (int j = 0; j <= m; j++) {
    ans = max(ans, f[j]);
}

/**
 * 倒序循环的原因 => 循环到 j 时
 * (1) F数组的后半部分 F[j~M] 处于 "第 i 个阶段"，也就是已经考虑过放入第 i 个物品的情况。
 * (2) 前半部分 F[0~j-1] 处于 "第 i-1 个阶段"，也就是还没有第 i 个物品更新。
 *     接下来 j 不断减小，意味着我们总是用 "第 i-1 个阶段" 的状态向 "第 i 个阶段" 的状态进行转移，
 * 符合线性 DP 的原则，进而保证了第 i 个物品只会被放入背包一次。
 *     然而，如果使用正序循环，假设 F[j] 被 F[j-V[i]] + W[i] 更新，接下来 j 增大到 j + V[i] 时，
 * F[j + V[i]] 又可能被 f[j] + W[i] 更新。此时，两个都处于 "第 i 个阶段" 的状态之间发生了转移，
 * 违背了线性 DP 的原则，相当于第 i 个物品被使用了两次。
 *     所以，在上面的代码中必须使用倒序循环，才符合0/1背包问题中每个物品是唯一的，
 * 只能放入背包一次的要求。
*/



/**
 * 完全背包 -> 模型如下
 *     给定 N 种物品，其中第 i 种物品的体积为 V[i]，价值为 W[i]，并且有无数个。有一容积为 M 的背包，
 * 要求选择若干个物品放入背包，使得物品总体积不超过 M 的前提下，物品的价值总和最大。
 *     先来考虑使用传统的二维线性 DP 的做法。设 F[i,j] 表示从前 i 种物品中选出了总体积为 j 的物品放入
 * 背包，物品的最大价值和。
 *     (1) F[i,j] = F[i-1,j]                          尚未选过第 i 种物品
 *     (2) F[i,j] = F[i,j-V[i]] + W[i]  if j >= V[i]  从第 i 种物品中选一个
 *         F[i,j] = max(F[i-1, j], F[i,j-V[i]] + W[i])
 * 
 *     初值: F[0,0] = 0, 其余均为负无穷。
 *     目标: 当 0 <= j <= M 时，max{F[N][j]}
 * 
 *     与 0/1 背包一样，我们也可以省略 F数组的 i 这一维。根据在 0/1背包中对循环顺序的分析，当采用正序
 * 循环时，就对应着每种物品可以使用无限次，也对应着 f[i,j] = f[i,j-v[i]] + w[i] 这个在两个均处于 
 * i 阶段的状态之间进行转移的方程。
*/


int f[MAX_M+1];
memset(f, 0xcf, sizeof(f));  // -INF
f[0] = 0;
for (int i = 1; i <= n; i++) {
    for (int j = v[i]; j <= m; j++) {
        f[j] = max(f[j], f[j - v[i]] + w[i]);
    }
}
int ans = 0;
for (int j = 0; j <= m; j++) {
    ans = max(ans, f[j]);
}